# -*- coding: utf-8 -*-
"""Copy of 2190101-10_TSD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x2O11EKFa7BBcsBkdZHPR7wW0WUWNO2A

# [`https://bit.ly/2190101-10_TSD`](https://bit.ly/2190101-10_TSD)

# Review

## nested list, nested loop, list comprehension
"""

x = 'BCC AC DS SK'
teams = x.split()
teams = sorted(teams)
n = len(teams)
print(teams)
matches = []
for i in range(n):
  for j in range(n):
    if teams[i] != teams[j]:
      print(teams[i], 'VS', teams[j])
      matches.append([teams[i], teams[j]])
print(matches)

for i in range(n):
  for j in range(i+1, n):
      print(teams[i], 'VS', teams[j])

"""## list comprehension"""

s = 'addl134a3a'
alphabets = [e for e in s if e not in '0123456789']
numbers = [e for e in s if e in '0123456789']
print(alphabets)
print(numbers)

x = ['2', '3.4', '4.5']
print([float(e) for e in x])

# [[1.0, 2.4, 3.3], [3.0, 5.0, -4.2], [6.0, 9.0, 11.2]]
s = '1.0:2.4:3.3, 3:5:-4.2,      6:9.0:11.2'
s = s.split(',')
print(s)
t = [e.strip().split(':') for e in s]
print(t)
t = [[float(x) for x in e] for e in t]
t

# sort by index 1 (desc), then by index 0 (asc)
x = [[1,2],[3,4],[5,2],[7,2]]
print(sorted(x))
x1 = [[-b,a] for a, b in x]
print(x)
print(x1)
x1.sort()
print(x1)
x2 = [[a, -b] for b, a in x1]
print(x2)



s = ['abcd', 'zcd', 'xy']
print(sorted(s))
# xy zcd abcd
t = [[-len(e), e] for e in s]
print(t)
print(sorted(t))

x =[['3', '4'], ['1', '2'], ['5', '2'], ['7', '2']]
print(x)
y = []
for i in range(len(x)):
    y += x[i]
    print(':', y)

z = []
for j in range(len(x[0])):
    for i in range(len(x)):
        z += x[i][j]
print(y)
print(z)

"""## `09_NestedLoop_★★_Factorization`

- Divide N with k = 2, 3, ... Anytime N is divisible by k, keep divide by k and count until not divisible
- store [k, count]
- find next k
- repeat until k > N

For example,
N = 200, k = 2 200 -> 100 -> 50 -> 25 -> 12.5 [2, 3] is part of answer
k = 3, 4 not divisible k = 5: 25 -> 5 -> 1 [5, 2] is part of answer
k = 6 > N = 1 stop
factor(200) -> [[2, 3], [5, 2]]
200=23∗52 
"""



"""## `09_NestedList_★★_Tiling_Puzzle`"""

def row_number(t, e): # return row number of t containing e (top row is row #0)
    pass

def flatten(t): # return a list of ints converted from list of lists of ints t
    pass

def inversions(x): # return the number of inversions of list x
    pass

def solvable(t): # return True if tiling t (list of lists of ints) is solvable
 # otherwise return False
    pass

print(row_number([[0,8,7],[6,5,4],[3,2,1]], 0)) #0
# print(flatten([[0,8,7],[6,5,4],[3,2,1]])) #[8, 7, 6, 5, 4, 3, 2, 1]
# print(inversions([8,7,6,5,4,3,2,1])) #28
# print(solvable([[0,8,7],[6,5,4],[3,2,1]])) #True

"""# `tuple, set, dict`

## tuple vs. list <br/>
Access data similar to list
- list can change its data
- tuple cannot change its data (unmutable)
"""

# list
a = [1, 2, 3, 7]

# tuple
t = (1, 2, 3, 7)

single_value = (99)
single_list = [99]
single_tuple = (99,)
print(type(single_value), single_value, len(str(single_value)))
print(type(single_list), single_list, len(single_list))
print(type(single_tuple), single_tuple, len(single_tuple))

# tuple can be created from list
s = '1 2'
t = s.split()
print(t, type(t))
z = tuple(t)
print(z[0])
print(z, type(z))

"""## **`set`**

Unordered and uniqued collection of data

 * methods: `add, remove, union,    intersection, difference, issubset`
 * `for e in set`
 * `if e in set`  (faster than `if e in list`)

"""

# dict  {key:value} key uniqued
# set   {key}       ไม่ซ้ำ
# unordered

d = {1:'x', 'y':3, 2:'z', 0:'x'}
s = set(['x', 1])
print(type(d), d)
print(type(s), s)
s = {-99, 3,2,1,0,1,2,5}
print(type(s), s, len(s))

"""## `add, remove, discard`"""

# set unordered list of data (no duplicate)
d = [4,1,2,4,5,6,5,4]
s = set(d)
print(d)
print(s)
s.add(3)
print('add 3:', s)
s.remove(1) # remove 1 from  set s
print('remove 1:', s)
s.add(2)
print('add 2:', s)
s.discard(6) #  after discard, s will not have value 6
print('discard 6:', s)

x = 2
s.discard(2)
if x in s:
    s.remove(x)
# s.discard(x)

s = {1,2,3}
v = 6
if v in s:
    s.remove(v)
s

t = {} # this is empty dict
s = set() # empty set
print(type(t), type(s))
print(s)
s.add(3)
s.add(10)
s.add(1)
print(s)
s.discard(9)
print(s)

"""## `union, intersection, difference, issubset`"""

# union, intersection, difference, issubset
s = set([1,2,3,4])
t = set([3,4,5,6])
print(s,t)
print('union:', s.union(t), s|t, t|s, t.union(s)) # create new set
print(s, t)
print('intersection:', s.intersection(t), s&t, t&s)
print('difference:', s.difference(t), s-t)
print('difference:', t.difference(s), t-s)
print(s.issubset(t), t.issubset(s))
print(s.issubset(s.union(t)), (s-t).issubset(s), (t-s).issubset(s))

"""## `for e in set:`"""

# for e in set:
s = set([3,7,-9, 14,3])
t = set([2,7,14])
for e in s:
  print(e)
print('-'*10)
for e in t:
  print(e)
print('-'*10)
for e in s.union(t):
  print(e)
print('-'*10)

"""## Creating tuple, set, list"""

a = [2,1,3,1,9,99,9999]
t = tuple(a)
s = set(a)
s2 = set([3,0,1,2])
print(t, s, s2)
print(s > s2, s < s2, s == s2)

# >, <, ==
s = {1,2,3,4,5}
t = {2,3,1,4,6}
if s > t: # t is subset of s
  print('s is greater')
elif s < t: # s is subset of t
  print('s is smaller')
elif s == t: # t is subset of s and s is subset of t
  print('equal')
else:
  print('should not print')

# from string
t = tuple("abcdd")
L = list("defgg")
s = set("xcdkk")
print(t, L, s)

# from list
a = [1, (1,),(1,2)]
b = set(a)
print(a, b)

x = [2,5,-3,7,-10,14,1,5,-3]
s = set(x)
print(s)
a_list = list(s)
a_list.sort(reverse=True)
print(a_list)

"""### dict using tuples as key"""

d = {(0,0): 'origin', (1,1):'siam one', (5,9):'mitretown'}
print(d)
print(d[(5,5)])

"""## Tips: using `zip()`"""

a = [1,2,3]
b = [9,8,7,6]
x = ['a', 'b', 'c']
c = zip(a, b, x)
print(*c)
d = [(a[i], b[i]) for i in range(min(len(a), len(b)))]
print(len(d), d)

# unzip
d = [(1, 'a'), (2, 'b'), (3, 'c')]
print(*d)
x, y = zip(*d)
print(x)
print(y)

"""## Comprehension

[`for element in iterable`]
"""

# list comprehension
a = [1 for _ in range(5)]
a

# dict comprehension
d = {i:i**2 for i in range(5)}
d

# set comprehension
set1 = {1,2,3,4,5}
set2 = {e for e in set1 if e%2 == 1}
set2

"""## Example of using list,set

1. Get input as list
2. Convert to set
3. Process set
4. Convert to list for sorting
5. Display result

# Grader

## `10_TSD_★_Union Intersection`
"""

# get input, converto set, using set operations

"""## `10_TSD_★_Winner`"""

# n
# win1 lose1
# win2 lose2
# ...
# winn losen

# teams that never loss are teams that not in losing

winning = set() # win1, win2, ... winn
losing = set() # lose1, lose2, ... losen

"""## `10_TSD_★_Database`"""

# database
# course.txt -> course_id, course_number
# teacher.txt -> teacher_id, teacher_name
# database.txt -> course_id, teacher_id

# read course.txt -> {course_id:course_number}
# read teach.txt -> {teacher_id:teacher_name}
# database -> [[course_id, teacher_id], ...]
for course_id, teacher_id in database:
  if course_id in course:
    course_name = ?
  else:
    ?
  if teacher_id in teacher:
    ?
  if ok:
    print(course,number, teachername)
  else:
    print('record error')

"""## `10_TSD_★★_GenreTotalPlaytime`"""

# total play time
# n
# song, singer, type, time

# songs = { type1:[time1, time2], type2:[time3, ...], ...}
#  { pop:[3,4,5], rock:[4,2], ...}

# [['pop', 3+4+5], ['rock', 4,2], ...]

# [[total_time, type], ...]
# sort
# convert back to [[type, total_time], ...]

# display first K song types
#   change total_time from sec -> min:sec

"""## `10_TSD_★★_Cartoon`"""

# Cartoon
# cartoon_name, type

# { type1:[name1, name2, ...], type2:[namex, ...]}
# Since Grader using Python 3.5, dict is unordered
# You have to store the order of data input for sorting later

# {bear:[[1, ted, fozzy]], dog:[2, gooffy]}

# create result list sorted by k

# show result

"""## `10_TSD_★★_Location Analysis`"""

# location analysis

# n
# id1, x11,x12,x13
# id2, x21,x22
# id3, x31,x32,x33,x34
# ...
# idn, xn1, ...

# id from input()

# person_travel = { person_id: [town]}
# {id1: [x11, x12, x13], id2:[x21,..], ...}

# towns = { town_name: [id1, id2, ...], ...}
# {x11:[id1], x12:[id1,id2], x13:[id1], x22:[id2]}

person_travel[id] = [towns visited]

for town in [towns visited]:
  towns[town] => list of person visitted the town

"""## `10_TSD_★★_Celebrity`"""

def xinput():
    return data.pop(0)
    
def knows(R,x,y):
    # return True if x knows y
    pass

def is_celeb(R, x):
    # return True if a is celeb, otherwise return False
    # return False if x knows someone who is not him/herself
    # return False if there exists someone in R who don't know x
    # otherwise return True
    pass

def find_celeb(R):
    # for each person x in the party
    # if x is celeb --> return x
    # if no celeb in the party --> return None
    pass

def read_relations() :
    # build a dictionary R from inputs
    # whose structure is shown in the example
    R = dict()
    names = set()
    while True:
        d = xinput().split()
        if len(d) == 1 : break
    pass

def main():
    R = read_relations()
    c = find_celeb(R)
    if c == None :
        print('Not Found')
    else:
        print(c)

data = ['Ploy Pat',
    'Ploy Boy',
    'Eak Pat',
    'Boy Pat',
    'Poom Pat',
    'Boy Eak',
    'q']
main()
# print(read_relations())
# print(find_celeb({'A':{'A'}}),find_celeb({'A':{'A'},'B':{'B'}}))
# exec(input().strip()) # do not remove this line
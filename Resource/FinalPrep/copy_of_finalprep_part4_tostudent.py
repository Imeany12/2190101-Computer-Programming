# -*- coding: utf-8 -*-
"""Copy of FinalPrep_Part4_ToStudent.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11A0urpWx3b5TFpa1ObHJiYzjmhTuJuG1

# Final Preparation Part4
Objective: 


*   Lecture10: Tuple/Set/Dict
*   Lecture11: Numpy
*   Lecture12: Class

## Question 4.1 (1 mark)

```
import numpy as np
def f1(x, a): 
    # x is a 1-D numpy array of ints, a is int
    # changes all data in x that has the value equal to minimum of all, to a
    m = x[0]
    for e in x[1:]:
        if e < m: 
            m = e
    for i in range(len(x)):
        if x[i] == m: 
            x[i] = a
```
Insert code to the underlined space of function `f2()` below to make `f2()` works similar to function `f1()` without using `for`, `while`, or comprehension.

```
def f2(x, a):
    x[_______________] = a

```
"""

#@title Answer
#@markdown Ignore " sign

answer =  "np.where(x == np.min(x))"#@param {type:"raw"}

import numpy as np

x = np.array([2,3,4,5,6,7,8,2])
y = x.copy()
def f1(x, a): 
    # x is a 1-D numpy array of ints, a is int
    # changes all data in x that has the value equal to minimum of all, to a
    m = x[0]
    for e in x[1:]:
        if e < m: 
            m = e
    for i in range(len(x)):
        if x[i] == m: 
            x[i] = a
f1(x,0)
print(x)
def f2(y, a) :
  y[np.where(y == np.min(y))] = a
f2(y,0)
print(y)

"""## Question 4.2 (1 mark)
```
import numpy as np

# Run f1() with some of your example to see the behavior of f1()
# Hint: you need to rearrange x

def f1(x): # x is a 1-D numpy array
    n = len(x)
    D = np.ndarray((n,n), x.dtype) # create empty matrix NxN with same dtype as x
    for i in range(n):
        for j in range(n):
            D[i,j] = x[i]+x[j]
    return D
```
Insert code to the underlined space of function `f2()` below to make `f2()` works similar to function `f1()` without using `for`, `while`, or comprehension.
```
def f2(x): # x is a 1-D numpy array
    a = __________
    return x + a
```
"""

#@title Answer
#@markdown Ignore " sign
answer =  'np.array(x).reshape(7,1)'#@param {type:"raw"}

import numpy as np

x = np.array([2,3,4,5,6,7,8])

def f1(x): # x is a 1-D numpy array
    n = len(x)
    D = np.ndarray((n,n), x.dtype) # create empty matrix NxN with same dtype as x
    for i in range(n):
        for j in range(n):
            D[i,j] = x[i]+x[j]
    return D

def f2(x):
    a = np.array(x).reshape(7,1)
    return x + a

print(f1(x))
print(f2(x))

"""## Question 4.3 (1 mark)

```
import numpy as np
def f1(x, a, b): 
    # x is a 1-D numpy array of ints, a and b are int
    return np.array([e for e in x if a <= e <= b])
```
Insert code to the underlined space of function `f2()` below to make `f2()` works similar to function `f1()` without using `for`, `while`, or comprehension.
```
def f2(x, a, b):
    return x[ _________________ ]
```
"""

#@title Answer
#@markdown Ignore " sign

answer = "x[a <= x] <= b" #@param {type:"raw"}

import numpy as np
def f1(x, a, b): 
    # x is a 1-D numpy array of ints, a and b are int
    return np.array([e for e in x if a <= e <= b])

def f2(x,a,b) :
    return x[x[a <= x] <= b]
print(f1(np.array([1,2,3,4,5,6,7]),1,4))
print(f2(np.array([1,2,3,4,5,6,7]),1,4))

"""## Question 4.4 (2 mark)

Implement function `eq(A, B, p)` where `A` and `B` are numpy arrays with same shape (any dimension), `p` is an integer from 0 to 100, inclusive.

The function should return `True` when the data of A and B at the same location are equal at least p percent. Otherwise, return `False`.

For example,

```
    A             B
1 2 3 4 5     1 2 3 4 5   
6 7 8 9 0     0 9 8 7 6

# of equal = 6 which are 1,2,3,4,5,8
out of 10 elements

eq(A, B, 50) -> True
eq(A, B, 60) -> True
eq(A, B, 61) -> False
eq(A, B, 70) -> False
```

**Maximum number of statements allowed including return is 3 statements**
"""

import numpy as np
def eq(A, B, p):
    # add your codes here
    # at most 3 statements including return
    C = A.reshape(1,len(A)*len(A[0])) - B.reshape(1,len(B)*len(B[0]))
    ref = np.sum(C == 0)/len(C[0])*100
    return p <= ref

"""## Question 4.5 (5 marks)

In HW4 when we look at a map, there are paths. A path has three properties, source, destination, and stamina cost between nodes.
From file name Isus.png
From figure above, there are 13 paths
```
1. A <- 3 -> K
2. A <- 7 -> J
3. B <- 1 -> C
4. B <- 7 -> F
5. C <- 2 -> D
6. C <- 6 -> G
7. D <- 8 -> J
8. E <- 1 -> F
9. F <- 4 -> H
10. G <- 3 -> I
11. G <- 5 -> K
12. H <- 2 -> I
13. H <- 5 -> K
```
Note that for a path, e.g. A to K with cost 3, has path from A to K and K to A, but we only represent it as a single path A to K as show in path 1, showing by alphabetical order (letter A comes before letter K).  The other paths are similar.

Your work is to define a new class Path that has the properties and behaviors as described.

Following is are examples code using class Path.  You need to implement class `Path` so that the programs output are the same as shown.  

**`Example 1`**
```
print('creating a path')
p1 = Path('X', 'T', 5)
print(p1.src, p1.dest, p1.cost)
p2 = Path('T', 'X', 5)
print(p2.src, p2.dest, p2.cost)

```
**`Output 1:`**
```
creating a path
T X 5
T X 5
```

**`Example 2:`**
```
print(Path('X1', 'X2', 10)
```
**`Output 2:`**
```
|X1| <-- 10 --> |x2|
```

The order of the path after sorted,
1. larger to smaller cost
2. if costs are the same sort by node1 name in alphabetical order

**`Example 3`**
```
print('list of paths...')
paths = [
    Path('A', 'K', 3), Path('A', 'J', 7), Path('B', 'C', 1), Path('B', 'F', 7),
    Path('C', 'D', 2), Path('C', 'G', 6), Path('D', 'J', 8), Path('E', 'F', 1),
    Path('F', 'H', 4), Path('G', 'I', 3), Path('G', 'K', 5), Path('H', 'I', 2),
    Path('H', 'K', 5)
]
paths.sort()
for p in paths:
    print(p)
```
**`Output 3`:**
```
list of paths...
|D| <-- 8 --> |J|
|A| <-- 7 --> |J|
|B| <-- 7 --> |F|
|C| <-- 6 --> |G|
|G| <-- 5 --> |K|
|H| <-- 5 --> |K|
|F| <-- 4 --> |H|
|A| <-- 3 --> |K|
|G| <-- 3 --> |I|
|C| <-- 2 --> |D|
|H| <-- 2 --> |I|
|B| <-- 1 --> |C|
|E| <-- 1 --> |F|
```
"""

# implement your code here
# Add all methods that make this class works as shown in examples above
# Run this cell before running the test cells
# def Path:
class Path:
  def __init__(self,src,dest,cost) :
    self.src = src
    self.dest = dest
    self.cost = cost
  def __str__(self) :
    return "|"+str(self.src)+"|" + " <-- " + str(self.cost) + " --> " + "|"+str(self.dest)+"|"
  def __lt__(self,x) :
    if self.cost != x.cost :
      return not(int(self.cost) < int(x.cost))
    else :
      return not(str(self.src) < str(x.src))

# DO NOT MODIFY THIS CELL
# Run this code cell to test that the object initialization is correct
print('creating a path')
p1 = Path('X', 'T', 5)
print(p1.src, p1.dest, p1.cost)
p2 = Path('T', 'X', 5)
print(p2.src, p2.dest, p2.cost)

# DO NOT MODIFY THIS CELL
# Run this code cell to test the output from printing
print(Path('X1', 'X2', 10))

# DO NOT MODIFY THIS CELL
# Run this code cell should produce output similar to the instruction
print('list of paths...')
paths = [
    Path('A', 'K', 3), Path('A', 'J', 7), Path('B', 'C', 1), Path('B', 'F', 7),
    Path('C', 'D', 2), Path('C', 'G', 6), Path('D', 'J', 8), Path('E', 'F', 1),
    Path('F', 'H', 4), Path('G', 'I', 3), Path('G', 'K', 5), Path('H', 'I', 2),
    Path('H', 'K', 5)
]
paths.sort()
for p in paths:
    print(p)

"""# Your code for testing

Insert code cell after this if you need to run parts of your code for testing only.  It will not be marked.
"""

# TEMP WORKING
# WILL NOT BE MARKED